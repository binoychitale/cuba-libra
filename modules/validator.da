import sys
import time
from typing import Dict, Tuple

from main.main import Main
from nacl.signing import SigningKey, VerifyKey
from safety.safety import Safety


class Validator(process):
    def setup(
        ps: set,
        id: int,
        key_pair: Tuple[SigningKey, VerifyKey],
        public_key_map: Dict[int, VerifyKey],
    ):
        # do any additional setup here
        self.local_timeout_time = round(time.time() * 1000)

        self.safety = Safety()

    def cs(task):
        # to enter cs, enque and send request to all, then await replies from all
        --start
        reqc = logical_clock()
        send(("Request", reqc), to=ps)

        await (len(replied) == len(ps))

        # critical section
        task()

        # to exit cs, deque and send releases to all
        --release
        reqc = None
        send(("Reply", logical_clock()), to=waiting)
        --end
        waiting = set()
        replied = set()

    def run():
        exit()
        while True:
            --receive
            # Check if 5 seconds have elapsed since timer was set
            if round(time.time() * 1000) - self.local_timeout_time > 5000:
                send(("Message-Local-Timeout", ""), to=self)

    # Have a separate receive handler for each type of message

    def receive(msg=("Message-Local-Timeout", body), from_=source):
        # Pacemaker handle local timeout
        print(f"Timed out locally at: {id}")

    def receive(msg=("Message-Proposal", body), from_=source):
        # Handle message proposal
        print("Proposal received")

    def receive(msg=("Message-Vote", body), from_=source):
        # Handle vote message
        print("Vote received")

    def receive(msg=("Message-Timeout", body), from_=source):
        # Handle remote timeout message
        print("Timeout received")
