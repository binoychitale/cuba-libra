import sys
import time
from typing import Dict, Tuple, List

from nacl import encoding
from nacl.signing import SignedMessage, SigningKey, VerifyKey

from modules.block_tree.block_tree import BlockTree
from modules.leaderelection.leaderelection import LeaderElection
from modules.ledger.ledger import Ledger
from modules.main.main import Main
from modules.objects import (
    MsgType,
    ProposalMessage,
    Signatures,
    TimeoutMessage,
    Transaction,
    VoteMsg,
)
from modules.pacemaker.pacemaker import Pacemaker
from modules.safety.safety import Safety
from modules.mempool.mempool import MemPool

client = import_da('client')


class Validator(process):
    def setup(
        ps: set,
        id: int,
        f: int,
        key_pair: Tuple[SigningKey, VerifyKey],
        public_key_map: Dict[int, VerifyKey],
        validator_map: Dict[int, Validator],
        validator_keypair_map: Dict[int, Tuple[SigningKey, VerifyKey]],
        client_map: Dict[int, client.Client],
    ):
        # do any additional setup here
        self.local_timeout_time = round(time.time() * 1000)

        self.safety = Safety(key_pair[0], validator_keypair_map, id)
        ledger = Ledger(id)
        block_tree = BlockTree(ledger, f, id)
        leader_election = LeaderElection(len(public_key_map.keys()))
        pacemaker = Pacemaker(f, id)
        self.mempool = MemPool()
        self.main = Main(block_tree, leader_election, pacemaker, safety, ledger, mempool, id)
        
        self.validator_id = id
        self.round_done = False
        self.client_map = client_map
        self.all_validators = ps | set([self])

    def run():
        while True:
            --receive
            # Check if 5 seconds have elapsed since timer was set
            if (
                self.main.check_if_current_leader()
                and self.main.pacemaker.current_round == 0
                and len(self.mempool.queue) > 0
            ):
                # Send a proposal
                proposal = self.main.get_next_proposal(None)
                if proposal:
                    send(
                        (
                            "Message-Proposal",
                            (proposal.create_signed_payload(key_pair[0])),
                        ),
                        to=self.ps
                    )
            if await (self.main.round_done or len(self.mempool.queue) > 0):
                self.main.round_done = False
            elif timeout(5):
                print(
                    "Local timeout at %s for round %s"
                    % (self.validator_id, self.main.pacemaker.current_round)
                )

                timeout_msg: TimeoutMessage = self.main.pacemaker.local_timeout_round(
                    self.main.safety, self.main.block_tree
                )
                send(
                    (
                        "Message-Timeout",
                        (timeout_msg.create_signed_payload(key_pair[0])),
                    ),
                    to=self.all_validators,
                )

    # Have a separate receive handler for each type of message

    def receive(msg=("Client-Transaction", body), from_=source):
        #output("Received {} at validator {}".format(body, self.validator_id))
        self.mempool.queue[body.id] = body
        #output("Mempool size {}", len(self.mempool.queue))

    def receive(msg=("Message-Proposal", body), from_=source):
        # Handle message proposal
        print(
            "Proposal received at: %s for round: %s"
            % (self.validator_id, self.main.pacemaker.current_round)
        )
        
        proposal: ProposalMessage = body[0]
        signed_proposal: SignedMessage = body[1]
        if not proposal.verify_signed_payload(
            signed_proposal, validator_keypair_map[proposal.sender_id][1]
        ):
            raise Exception("There is an imposter among us !!")
        
        vote: VoteMsg = self.main.process_proposal_msg(proposal)
        next_leader = self.main.leader_election.get_leader(
            self.main.pacemaker.current_round
        )
        #print("VOTE", vote, "Round", self.main.pacemaker.current_round, "Next Leader:", next_leader, "Validator:",self.validator_id)
        if vote:
            send(
                ("Message-Vote", (vote.create_signed_payload(key_pair[0]), proposal.trx_ids)),
                to=validator_map[next_leader],
            )
        else:
            output(
                "Ledger: ",
                list(([trx.command for trx in cb.block.payload] for cb in self.main.ledger.ledger)),
                "Validator {}".format(self.validator_id),
            )
            output("Rounds: ", [cb.block.round for cb in self.main.ledger.ledger])

    def receive(msg=("Message-Vote", body), from_=source):
        # Handle vote message
        vote: VoteMsg = body[0][0]
        signed_vote: SignedMessage = body[0][1]
        trx_ids: List[str] = body[1]
        print(
            "Vote received at %s for round %s from %s"
            % (self.validator_id, self.main.pacemaker.current_round, vote.sender)
        )

        if not vote.verify_signed_payload(signed_vote, validator_keypair_map[vote.sender][1]):
            raise Exception("There is an imposter among us !!")

        new_qc = self.main.process_vote_msg(vote)
        if new_qc:
            trx_client_map = self.main.deque_trx(trx_ids)
            for trx_id, client_id in trx_client_map.items():
                send(
                    ("Client-Reply", (trx_id, self.validator_id)),
                    to=self.client_map[client_id],
                )
            
            send(
                    ("Deque-Transaction", trx_ids),
                    to=self.ps,
                )
            """await(some(received(('Dequed', id)), has = (
                id == self.main.leader_election.get_leader(self.main.pacemaker.current_round)
            )))"""
            """num_received = 0
            while num_received != len(validator_map):
                if await(some(received(('Dequed')))):
                    num_received += 1
                elif timeout(5):
                    break"""
            
            next_proposal = self.main.get_next_proposal(new_qc)
            if next_proposal:
                send(
                    (
                        "Message-Proposal",
                        (next_proposal.create_signed_payload(key_pair[0])),
                    ),
                    to=self.ps,
                )
            else:
                output("Ledger: ", [trx.command for trx in self.main.ledger.ledger[-1].block.payload], "Round {}, Validator {}".format(self.main.pacemaker.current_round, self.validator_id))
    
    def receive(msg=("Deque-Transaction", trx_ids), from_=source):
        trx_client_map = self.main.deque_trx(trx_ids)
        #send(('Dequed', self.validator_id), to=source)
        #send(('Dequed'), to=source)

        for trx_id, client_id in trx_client_map.items():
            send(
                ("Client-Reply", (trx_id, self.validator_id)),
                to=self.client_map[client_id],
            )

    def receive(msg=("Message-Timeout", body), from_=source):
        # Handle remote timeout message
        print(f"Timeout received at: {id}")

        timeout_msg: TimeoutMessage = body[0]
        signed_timeout: SignedMessage = body[1]

        if not timeout_msg.verify_signed_payload(
            signed_timeout, validator_keypair_map[timeout_msg.id][1]
        ):
            raise Exception("There is an imposter among us !!")

        new_proposal = self.main.process_timeout_msg(timeout_msg)
        if new_proposal:
            print(
                f"Timeout certificate at: {id} for round {new_proposal.last_round_tc.round}"
            )
            send(
                (
                    "Message-Proposal",
                    (new_proposal.create_signed_payload(key_pair[0])),
                ),
                to=ps,
            )

    def get_validator_id():
        return self.validator_id

    def get_leader():
        self.main.leader_election.get_leader(self.main.pacemaker.current_round)

    def get_current_round():
        return self.main.pacemaker.current_round

    def set_current_round(round):
        self.main.pacemaker.current_round = round

    def set_highest_vote_count(highest_vote_round):
        self.main.safety.highest_vote_round = highest_vote_round

    def get_validator_map():
        return self.validator_map
