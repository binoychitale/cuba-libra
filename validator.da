import sys
import time
from typing import Dict, Tuple

from nacl.signing import SigningKey, VerifyKey

from modules.block_tree.block_tree import BlockTree
from modules.leaderelection.leaderelection import LeaderElection
from modules.ledger.ledger import Ledger
from modules.main.main import Main
from modules.objects import ProposalMessage, Transaction
from modules.pacemaker.pacemaker import Pacemaker
from modules.safety.safety import Safety


class Validator(process):
    def setup(
        ps: set,
        id: int,
        f: int,
        key_pair: Tuple[SigningKey, VerifyKey],
        public_key_map: Dict[int, VerifyKey],
        validator_map: Dict[int, Validator],
    ):
        # do any additional setup here
        self.local_timeout_time = round(time.time() * 1000)

        self.safety = Safety(key_pair[0], key_pair[1])
        ledger = Ledger()
        block_tree = BlockTree(ledger, f, id)
        leader_election = LeaderElection(len(public_key_map.keys()))
        pacemaker = Pacemaker(f)
        self.main = Main(block_tree, leader_election, pacemaker, safety, ledger, id)
        self.validator_id = id

    def run():
        while True:
            --receive
            # Check if 5 seconds have elapsed since timer was set
            if (
                self.main.check_if_current_leader()
                and self.main.pacemaker.current_round == 0
            ):
                # Send a proposal
                send(
                    ("Message-Proposal", self.main.get_next_proposal(None)), to=self.ps
                )

            if round(time.time() * 1000) - self.local_timeout_time > 5000:
                send(("Message-Local-Timeout", ""), to=self)

    # Have a separate receive handler for each type of message

    def receive(msg=("Message-Local-Timeout", body), from_=source):
        # Pacemaker handle local timeout
        print(f"Timed out locally at: {id}")

    def receive(msg=("Message-Proposal", body), from_=source):
        # Handle message proposal
        print(
            "Proposal received at %s for round %s"
            % (self.validator_id, self.main.pacemaker.current_round)
        )
        vote = self.main.process_proposal_msg(body)
        next_leader = self.main.leader_election.get_leader(
            self.main.pacemaker.current_round
        )
        print("VOTE", vote)
        send(("Message-Vote", vote), to=validator_map[next_leader])

    def receive(msg=("Message-Vote", body), from_=source):
        # Handle vote message
        print(
            "Vote received at %s for round %s"
            % (self.validator_id, self.main.pacemaker.current_round)
        )
        new_qc = self.main.process_vote_msg(body)
        if new_qc:
            next_proposal = self.main.get_next_proposal(new_qc)
            send(
                ("Message-Proposal", next_proposal),
                to=self.ps,
            )

    def receive(msg=("Message-Timeout", body), from_=source):
        # Handle remote timeout message
        print("Timeout received")
