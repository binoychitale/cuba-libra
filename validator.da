import sys
import time
from typing import Dict, Tuple

from nacl.signing import SigningKey, VerifyKey

from modules.block_tree.block_tree import BlockTree
from modules.leaderelection.leaderelection import LeaderElection
from modules.ledger.ledger import Ledger
from modules.main.main import Main
from modules.objects import ProposalMessage, Transaction
from modules.pacemaker.pacemaker import Pacemaker
from modules.safety.safety import Safety


class Validator(process):
    def setup(
        ps: set,
        id: int,
        f: int,
        key_pair: Tuple[SigningKey, VerifyKey],
        public_key_map: Dict[int, VerifyKey],
        validator_map: Dict[int, Validator],
    ):
        # do any additional setup here
        self.local_timeout_time = round(time.time() * 1000)

        self.safety = Safety(key_pair[0], key_pair[1])
        ledger = Ledger()
        block_tree = BlockTree(ledger, f, id)
        leader_election = LeaderElection(len(public_key_map.keys()))
        pacemaker = Pacemaker(f)
        self.main = Main(block_tree, leader_election, pacemaker, safety, ledger, id)
        self.validator_id = id

    def run():
        while True:
            --receive
            # Check if 5 seconds have elapsed since timer was set
            if (
                self.main.check_if_current_leader()
                and self.main.pacemaker.current_round == 0
            ):
                # Send a proposal
                # dummy transaction
                trans = Transaction("hello")
                new_block = self.main.block_tree.generate_block(
                    [trans], self.main.pacemaker.current_round
                )
                self.main.block_tree.execute_and_insert(new_block)
                proposal = ProposalMessage(
                    new_block, None, None, None, self.validator_id
                )
                self.main.pacemaker.start_timer(self.main.pacemaker.current_round + 1)
                send(("Message-Proposal", proposal), to=self.ps)

            if round(time.time() * 1000) - self.local_timeout_time > 5000:
                send(("Message-Local-Timeout", ""), to=self)

    # Have a separate receive handler for each type of message

    def receive(msg=("Message-Local-Timeout", body), from_=source):
        # Pacemaker handle local timeout
        print(f"Timed out locally at: {id}")

    def receive(msg=("Message-Proposal", body), from_=source):
        # Handle message proposal
        print("Proposal received at %s" % (self.validator_id))
        vote = self.main.process_proposal_msg(body)
        next_leader = self.main.leader_election.get_leader(
            self.main.pacemaker.current_round + 1
        )
        send(("Message-Vote", vote), to=validator_map[next_leader])

    def receive(msg=("Message-Vote", body), from_=source):
        # Handle vote message
        print("Vote received at %s" % (self.validator_id))

    def receive(msg=("Message-Timeout", body), from_=source):
        # Handle remote timeout message
        print("Timeout received")
