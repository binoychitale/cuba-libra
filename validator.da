import sys
import time
from typing import Dict, Tuple

from nacl import encoding
from nacl.signing import SignedMessage, SigningKey, VerifyKey

from modules.block_tree.block_tree import BlockTree
from modules.leaderelection.leaderelection import LeaderElection
from modules.ledger.ledger import Ledger
from modules.main.main import Main
from modules.objects import (
    ProposalMessage,
    Signatures,
    TimeoutMessage,
    Transaction,
    VoteMsg,
)
from modules.pacemaker.pacemaker import Pacemaker
from modules.safety.safety import Safety


class Validator(process):
    def setup(
        ps: set,
        id: int,
        f: int,
        key_pair: Tuple[SigningKey, VerifyKey],
        public_key_map: Dict[int, VerifyKey],
        validator_map: Dict[int, Validator],
        kv_pairs_map: Dict[int, Tuple[SigningKey, VerifyKey]],
    ):
        # do any additional setup here
        self.local_timeout_time = round(time.time() * 1000)

        self.safety = Safety(key_pair[0], key_pair[1], id)
        ledger = Ledger()
        block_tree = BlockTree(ledger, f, id)
        leader_election = LeaderElection(len(public_key_map.keys()))
        pacemaker = Pacemaker(f, id)
        self.main = Main(block_tree, leader_election, pacemaker, safety, ledger, id)
        self.validator_id = id
        self.round_done = False

    def run():
        while True:
            --receive
            # Check if 5 seconds have elapsed since timer was set
            if (
                self.main.check_if_current_leader()
                and self.main.pacemaker.current_round == 0
            ):
                # Send a proposal
                proposal: ProposalMessage = self.main.get_next_proposal(None)
                send(
                    (
                        "Message-Proposal",
                        (proposal.create_signed_payload(key_pair[0])),
                    ),
                    to=self.ps,
                )

            if await (self.main.round_done):
                self.main.round_done = False
            elif timeout(5):
                print(
                    "Local timeout at %s for round %s"
                    % (self.validator_id, self.main.pacemaker.current_round)
                )

                recv_set = ps
                ps.add(self)

                timeout_msg: TimeoutMessage = self.main.pacemaker.local_timeout_round(
                    self.main.safety, self.main.block_tree
                )

                send(
                    (
                        "Message-Timeout",
                        (timeout_msg._sign_timeout_msg(key_pair[0])),
                    ),
                    to=ps,
                )

    # Have a separate receive handler for each type of message
    def receive(msg=("Message-Proposal", body), from_=source):
        # Handle message proposal
        print(
            "Proposal received at: %s for round: %s"
            % (self.validator_id, self.main.pacemaker.current_round)
        )
        proposal: ProposalMessage = body[0]
        signed_proposal: SignedMessage = body[1]

        if not proposal.verify_signed_payload(
            signed_proposal, kv_pairs_map[proposal.sender_id][1]
        ):
            raise Exception("There is an imposter among us !!")

        vote: VoteMsg = self.main.process_proposal_msg(proposal)
        next_leader = self.main.leader_election.get_leader(
            self.main.pacemaker.current_round
        )
        send(
            ("Message-Vote", (vote.create_signed_payload(key_pair[0]))),
            to=validator_map[next_leader],
        )

    def receive(msg=("Message-Vote", body), from_=source):
        # Handle vote message
        vote: VoteMsg = body[0]
        signed_vote: SignedMessage = body[1]
        print(
            "Vote received at %s for round %s from %s"
            % (self.validator_id, self.main.pacemaker.current_round, vote.sender)
        )

        if not vote.verify_signed_payload(signed_vote, kv_pairs_map[vote.sender][1]):
            raise Exception("There is an imposter among us !!")

        new_qc = self.main.process_vote_msg(vote)
        if new_qc:
            next_proposal = self.main.get_next_proposal(new_qc)
            send(
                (
                    "Message-Proposal",
                    (next_proposal.create_signed_payload(key_pair[0])),
                ),
                to=self.ps,
            )

    def receive(msg=("Message-Timeout", body), from_=source):
        # Handle remote timeout message
        print(f"Timeout received at: {id}")
        new_proposal = self.main.process_timeout_msg(body)
        if new_proposal is not None:
            print(
                f"Timeout certificate at: {id} for round {new_proposal.last_round_tc.round}"
            )
            send(
                (
                    "Message-Proposal",
                    (new_proposal.create_signed_payload(key_pair[0])),
                ),
                to=ps,
            )
